DEBUG: com.blazingdb.calcite.schema.BlazingSchema - getting table names
DEBUG: com.blazingdb.calcite.application.RelationalAlgebraGenerator - non optimized
LogicalProject(log_time=[$0], node_id=[$1], type=[$2], query_id=[$3], step=[$4], substep=[$5], info=[$6], duration=[$7], extra1=[$8], data1=[$9], extra2=[$10], data2=[$11])
  LogicalTableScan(table=[[main, bsql_logs]])

DEBUG: com.blazingdb.calcite.application.RelationalAlgebraGenerator - optimized
LogicalTableScan(table=[[main, bsql_logs]])

DEBUG: com.blazingdb.calcite.application.RelationalAlgebraGenerator - non optimized
LogicalSort(sort0=[$0], dir0=[DESC])
  LogicalProject(log_time=[$0], query_id=[$3], duration=[$7])
    LogicalFilter(condition=[=($6, 'Query Execution Done')])
      LogicalTableScan(table=[[main, bsql_logs]])

DEBUG: com.blazingdb.calcite.application.RelationalAlgebraGenerator - optimized
LogicalSort(sort0=[$0], dir0=[DESC])
  LogicalProject(log_time=[$0], query_id=[$1], duration=[$3])
    BindableTableScan(table=[[main, bsql_logs]], filters=[[=($2, 'Query Execution Done')]], projects=[[0, 3, 6, 7]], aliases=[[log_time, query_id, $f2, duration]])

DEBUG: com.blazingdb.calcite.application.RelationalAlgebraGenerator - non optimized
LogicalSort(sort0=[$0], dir0=[DESC])
  LogicalProject(end_time=[$1], query_id=[$0], load_time=[$2], total_time=[$3])
    LogicalAggregate(group=[{0}], end_time=[MAX($1)], load_time=[MAX($2)], total_time=[MAX($3)])
      LogicalProject(query_id=[$1], end_time=[$4], load_time=[$2], total_time=[$3])
        LogicalAggregate(group=[{0, 1}], load_time=[SUM($2)], total_time=[SUM($3)], end_time=[MAX($4)])
          LogicalProject(node_id=[$1], query_id=[$3], $f2=[CASE(=($6, 'evaluate_split_query load_data'), $7, 0:FLOAT)], $f3=[CASE(=($6, 'Query Execution Done'), $7, 0:FLOAT)], log_time=[$0])
            LogicalFilter(condition=[OR(=($6, 'evaluate_split_query load_data'), =($6, 'Query Execution Done'))])
              LogicalTableScan(table=[[main, bsql_logs]])

DEBUG: com.blazingdb.calcite.application.RelationalAlgebraGenerator - optimized
LogicalSort(sort0=[$0], dir0=[DESC])
  LogicalProject(end_time=[$1], query_id=[$0], load_time=[$2], total_time=[$3])
    LogicalAggregate(group=[{0}], end_time=[MAX($1)], load_time=[MAX($2)], total_time=[MAX($3)])
      LogicalProject(query_id=[$1], end_time=[$4], load_time=[$2], total_time=[$3])
        LogicalAggregate(group=[{0, 1}], load_time=[SUM($2)], total_time=[SUM($3)], end_time=[MAX($4)])
          LogicalProject(node_id=[$1], query_id=[$2], $f2=[CASE(=($3, 'evaluate_split_query load_data'), $4, 0:FLOAT)], $f3=[CASE(=($3, 'Query Execution Done'), $4, 0:FLOAT)], log_time=[$0])
            BindableTableScan(table=[[main, bsql_logs]], filters=[[OR(=($3, 'evaluate_split_query load_data'), =($3, 'Query Execution Done'))]], projects=[[0, 1, 3, 6, 7]], aliases=[[log_time, node_id, query_id, $f3, $f4]])

DEBUG: com.blazingdb.calcite.application.RelationalAlgebraGenerator - non optimized
LogicalProject(end_time=[$1], avg_time=[/($2, $3)], min_time=[$4], max_time=[$5], num_times=[$3], relational_algebra=[$0])
  LogicalAggregate(group=[{0}], end_time=[MAX($1)], agg#1=[SUM($2)], num_times=[COUNT($2)], min_time=[MIN($2)], max_time=[MAX($2)])
    LogicalProject(relational_algebra=[$6], end_time=[$1], query_duration=[$4])
      LogicalJoin(condition=[=($0, $5)], joinType=[inner])
        LogicalProject(query_id=[$0], end_time=[$1], avg_time=[/($2, $3)], min_time=[$4], max_time=[$5])
          LogicalAggregate(group=[{0}], end_time=[MAX($1)], agg#1=[SUM($2)], agg#2=[COUNT($2)], min_time=[MIN($2)], max_time=[MAX($2)])
            LogicalProject(query_id=[$3], log_time=[$0], duration=[$7])
              LogicalFilter(condition=[=($6, 'Query Execution Done')])
                LogicalTableScan(table=[[main, bsql_logs]])
        LogicalProject(query_id=[$0], relational_algebra=[SUBSTRING($1, 13, 2000)])
          LogicalAggregate(group=[{0, 1}])
            LogicalProject(query_id=[$3], info=[$6])
              LogicalFilter(condition=[LIKE($6, 'Query Start%')])
                LogicalTableScan(table=[[main, bsql_logs]])

DEBUG: com.blazingdb.calcite.application.RelationalAlgebraGenerator - optimized
LogicalProject(end_time=[$1], avg_time=[/($2, $3)], min_time=[$4], max_time=[$5], num_times=[$3], relational_algebra=[$0])
  LogicalAggregate(group=[{0}], end_time=[MAX($1)], agg#1=[SUM($2)], num_times=[COUNT($2)], min_time=[MIN($2)], max_time=[MAX($2)])
    LogicalProject(relational_algebra=[$4], end_time=[$1], query_duration=[$2])
      LogicalJoin(condition=[=($0, $3)], joinType=[inner])
        LogicalProject(query_id=[$0], end_time=[$1], max_time=[$5])
          LogicalAggregate(group=[{0}], end_time=[MAX($1)], agg#1=[SUM($2)], agg#2=[COUNT($2)], min_time=[MIN($2)], max_time=[MAX($2)])
            LogicalProject(query_id=[$1], log_time=[$0], duration=[$3])
              BindableTableScan(table=[[main, bsql_logs]], filters=[[=($2, 'Query Execution Done')]], projects=[[0, 3, 6, 7]], aliases=[[log_time, query_id, $f2, duration]])
        LogicalProject(query_id=[$0], relational_algebra=[SUBSTRING($1, 13, 2000)])
          LogicalAggregate(group=[{0, 1}])
            BindableTableScan(table=[[main, bsql_logs]], filters=[[LIKE($1, 'Query Start%')]], projects=[[3, 6]], aliases=[[query_id, info]])

